// Autogenerated from Pigeon (v26.1.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package dev.rohanjsh.pitcher.casting

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
private object CastingApiPigeonUtils {

  fun createConnectionError(channelName: String): CastingApiError {
    return CastingApiError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is CastingApiError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).contains(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class CastingApiError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/**
 * The casting technology/provider type.
 *
 * This enum allows the Flutter layer to understand which technology is being
 * used, while keeping the API unified. The native layer handles the specifics.
 */
enum class CastingProvider(val raw: Int) {
  /**
   * Google Cast (Chromecast, Android TV, Nest devices)
   * Available on: Android, iOS
   */
  CHROMECAST(0),
  /**
   * Apple AirPlay (Apple TV, AirPlay 2 speakers, AirPlay-enabled TVs)
   * Available on: iOS only
   */
  AIRPLAY(1);

  companion object {
    fun ofRaw(raw: Int): CastingProvider? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * The current state of the casting connection.
 *
 * Modeled after session states from Google Cast SDK.
 */
enum class CastingConnectionState(val raw: Int) {
  /** No casting session, not connected to any device */
  DISCONNECTED(0),
  /** Attempting to connect to a cast device */
  CONNECTING(1),
  /** Connected to a cast device, ready to load media */
  CONNECTED(2);

  companion object {
    fun ofRaw(raw: Int): CastingConnectionState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The current playback state on the remote device. */
enum class CastingPlaybackState(val raw: Int) {
  /** No media loaded */
  IDLE(0),
  /** Media is loading/buffering */
  LOADING(1),
  /** Media is playing */
  PLAYING(2),
  /** Media is paused */
  PAUSED(3),
  /** Playback has ended */
  ENDED(4),
  /** An error occurred during playback */
  ERROR(5);

  companion object {
    fun ofRaw(raw: Int): CastingPlaybackState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Media content type for proper receiver handling. */
enum class MediaType(val raw: Int) {
  /** Video content (movies, TV shows, video clips) */
  VIDEO(0),
  /** Audio content (music, podcasts, audiobooks) */
  AUDIO(1);

  companion object {
    fun ofRaw(raw: Int): MediaType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Represents a discovered cast-capable device.
 *
 * This is a unified representation that works for both Chromecast and AirPlay
 * devices. The [provider] field indicates which technology is being used.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CastDevice (
  /**
   * Unique identifier for the device.
   * - Chromecast: Route ID from MediaRouter
   * - AirPlay: UID from AVRouteDetector
   */
  val id: String,
  /** Human-readable device name (e.g., "Living Room TV") */
  val name: String,
  /** The casting technology this device uses */
  val provider: CastingProvider,
  /** Device model name if available (e.g., "Chromecast Ultra", "Apple TV 4K") */
  val modelName: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CastDevice {
      val id = pigeonVar_list[0] as String
      val name = pigeonVar_list[1] as String
      val provider = pigeonVar_list[2] as CastingProvider
      val modelName = pigeonVar_list[3] as String?
      return CastDevice(id, name, provider, modelName)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      name,
      provider,
      modelName,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CastDevice) {
      return false
    }
    if (this === other) {
      return true
    }
    return CastingApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Information about the media to be cast.
 *
 * Modeled after MediaInfo from Google Cast SDK.
 * @see https://developers.google.com/cast/docs/reference/android/com/google/android/gms/cast/MediaInfo
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MediaInfo (
  /**
   * URL of the media content.
   * Must be accessible by the receiver device (not localhost).
   */
  val contentUrl: String,
  /** Title displayed on the receiver (e.g., "Big Buck Bunny") */
  val title: String,
  /** Type of media content */
  val mediaType: MediaType,
  /** Subtitle/artist displayed on the receiver */
  val subtitle: String? = null,
  /** URL of the thumbnail/poster image */
  val imageUrl: String? = null,
  /**
   * MIME type of the content (e.g., "video/mp4", "audio/mpeg")
   * If not provided, the receiver will try to detect it.
   */
  val contentType: String? = null,
  /** Duration in milliseconds (optional, receiver can detect) */
  val duration: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MediaInfo {
      val contentUrl = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String
      val mediaType = pigeonVar_list[2] as MediaType
      val subtitle = pigeonVar_list[3] as String?
      val imageUrl = pigeonVar_list[4] as String?
      val contentType = pigeonVar_list[5] as String?
      val duration = pigeonVar_list[6] as Long?
      return MediaInfo(contentUrl, title, mediaType, subtitle, imageUrl, contentType, duration)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      contentUrl,
      title,
      mediaType,
      subtitle,
      imageUrl,
      contentType,
      duration,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is MediaInfo) {
      return false
    }
    if (this === other) {
      return true
    }
    return CastingApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Current state of the casting session and playback.
 *
 * Sent from native to Flutter via CastingFlutterApi.onStateChanged
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CastingState (
  /** Current connection state */
  val connectionState: CastingConnectionState,
  /** Current playback state */
  val playbackState: CastingPlaybackState,
  /** Currently connected device (null if disconnected) */
  val connectedDevice: CastDevice? = null,
  /** Currently loaded media (null if no media loaded) */
  val currentMedia: MediaInfo? = null,
  /** Current playback position in milliseconds */
  val positionMs: Long? = null,
  /** Total duration in milliseconds */
  val durationMs: Long? = null,
  /** Error message if playbackState is error */
  val errorMessage: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CastingState {
      val connectionState = pigeonVar_list[0] as CastingConnectionState
      val playbackState = pigeonVar_list[1] as CastingPlaybackState
      val connectedDevice = pigeonVar_list[2] as CastDevice?
      val currentMedia = pigeonVar_list[3] as MediaInfo?
      val positionMs = pigeonVar_list[4] as Long?
      val durationMs = pigeonVar_list[5] as Long?
      val errorMessage = pigeonVar_list[6] as String?
      return CastingState(connectionState, playbackState, connectedDevice, currentMedia, positionMs, durationMs, errorMessage)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      connectionState,
      playbackState,
      connectedDevice,
      currentMedia,
      positionMs,
      durationMs,
      errorMessage,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CastingState) {
      return false
    }
    if (this === other) {
      return true
    }
    return CastingApiPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class CastingApiPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CastingProvider.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CastingConnectionState.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CastingPlaybackState.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          MediaType.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CastDevice.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MediaInfo.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CastingState.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is CastingProvider -> {
        stream.write(129)
        writeValue(stream, value.raw.toLong())
      }
      is CastingConnectionState -> {
        stream.write(130)
        writeValue(stream, value.raw.toLong())
      }
      is CastingPlaybackState -> {
        stream.write(131)
        writeValue(stream, value.raw.toLong())
      }
      is MediaType -> {
        stream.write(132)
        writeValue(stream, value.raw.toLong())
      }
      is CastDevice -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is MediaInfo -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is CastingState -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * API for Flutter to call native platform code.
 *
 * This is the main interface for controlling casting from Dart.
 * Implementations exist for:
 * - Android: Chromecast via Cast SDK + MediaRouter
 * - iOS: Chromecast via Cast SDK + AirPlay via AVFoundation
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface CastingHostApi {
  /**
   * Start discovering all available cast devices.
   *
   * On Android: Discovers Chromecast devices via MediaRouter.
   * On iOS: Discovers Chromecast (GCKDiscoveryManager) + AirPlay (AVRouteDetector).
   *
   * Results are delivered via [CastingFlutterApi.onDevicesChanged].
   */
  fun startDiscovery()
  /** Stop all device discovery. */
  fun stopDiscovery()
  /** Get all currently discovered devices. */
  fun getDiscoveredDevices(): List<CastDevice>
  /**
   * Connect to a specific Chromecast device.
   *
   * ⚠️ IMPORTANT: This method only works for Chromecast devices!
   *
   * For AirPlay devices, use [showAirPlayPicker] instead - Apple requires
   * user interaction via their system UI (AVRoutePickerView).
   *
   * @param deviceId The unique ID of the Chromecast device to connect to.
   *
   * Connection state changes are delivered via CastingFlutterApi.onStateChanged.
   */
  fun connect(deviceId: String)
  /**
   * Disconnect from the current cast device.
   *
   * This will stop any playing media and end the casting session.
   * Works for both Chromecast and AirPlay.
   */
  fun disconnect()
  /**
   * Show the native AirPlay device picker (iOS only).
   *
   * This presents a system UI (AVRoutePickerView) where the user can select
   * an AirPlay device. Apple does not allow programmatic device selection.
   *
   * On Android: This is a no-op (AirPlay not available).
   *
   * After the user selects a device, the connection state will be updated
   * via CastingFlutterApi.onStateChanged.
   */
  fun showAirPlayPicker()
  /**
   * Load and start playing media on the connected device.
   *
   * @param mediaInfo Information about the media to play.
   * @param autoplay Whether to start playing immediately (default: true).
   * @param positionMs Starting position in milliseconds (default: 0).
   *
   * For Chromecast: Uses RemoteMediaClient.load()
   * For AirPlay: Configures AVPlayer with the URL
   */
  fun loadMedia(mediaInfo: MediaInfo, autoplay: Boolean, positionMs: Long)
  /** Resume playback of paused media. */
  fun play()
  /** Pause playback. */
  fun pause()
  /**
   * Seek to a specific position.
   *
   * @param positionMs Target position in milliseconds.
   */
  fun seek(positionMs: Long)
  /**
   * Stop playback and unload media.
   *
   * This does NOT disconnect from the device.
   */
  fun stop()
  /**
   * Set the playback volume on the receiver.
   *
   * @param volume Volume level from 0.0 to 1.0.
   */
  fun setVolume(volume: Double)
  /** Set mute state on the receiver. */
  fun setMuted(muted: Boolean)

  companion object {
    /** The codec used by CastingHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      CastingApiPigeonCodec()
    }
    /** Sets up an instance of `CastingHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: CastingHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.startDiscovery$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.startDiscovery()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.stopDiscovery$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.stopDiscovery()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.getDiscoveredDevices$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getDiscoveredDevices())
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.connect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val deviceIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.connect(deviceIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.disconnect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.disconnect()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.showAirPlayPicker$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.showAirPlayPicker()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.loadMedia$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val mediaInfoArg = args[0] as MediaInfo
            val autoplayArg = args[1] as Boolean
            val positionMsArg = args[2] as Long
            val wrapped: List<Any?> = try {
              api.loadMedia(mediaInfoArg, autoplayArg, positionMsArg)
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.play$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.play()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.pause$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.pause()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.seek$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val positionMsArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.seek(positionMsArg)
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.stop$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.stop()
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.setVolume$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val volumeArg = args[0] as Double
            val wrapped: List<Any?> = try {
              api.setVolume(volumeArg)
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pitcher.CastingHostApi.setMuted$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val mutedArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.setMuted(mutedArg)
              listOf(null)
            } catch (exception: Throwable) {
              CastingApiPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for native platform code to call Flutter.
 *
 * This enables the native layer to push updates to the Dart layer,
 * following an event-driven architecture pattern.
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class CastingFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by CastingFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      CastingApiPigeonCodec()
    }
  }
  /**
   * Called when the list of discovered devices changes.
   *
   * This is triggered when:
   * - A new device is discovered
   * - A device disappears (goes offline)
   * - Device properties change
   */
  fun onDevicesChanged(devicesArg: List<CastDevice>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pitcher.CastingFlutterApi.onDevicesChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(devicesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(CastingApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(CastingApiPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  /**
   * Called when the casting state changes.
   *
   * This includes:
   * - Connection state changes (connecting, connected, disconnected)
   * - Playback state changes (loading, playing, paused, ended)
   * - Position updates during playback
   * - Error events
   */
  fun onStateChanged(stateArg: CastingState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pitcher.CastingFlutterApi.onStateChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(CastingApiError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(CastingApiPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
